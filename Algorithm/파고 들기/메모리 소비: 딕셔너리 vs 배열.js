/** 
 메모이제이션을 활용하는 방법은 중복된 연산을 피하기 위해 계산된 결과를 저장하여 재사용하는 방법입니다. 이를 위해 배열이나 딕셔너리를 사용할 수 있습니다.

메모리 사용량 측면에서 배열을 활용하는 것이 딕셔너리보다 덜 사용합니다. 배열은 연속적인 메모리 공간에 요소를 저장하기 때문에 일반적으로 딕셔너리보다 더 적은 메모리를 사용합니다.

딕셔너리는 키-값 쌍으로 데이터를 저장하는 자료구조이며, 메모리 상에서 키와 값은 분리된 공간에 저장됩니다. 따라서 키와 값 사이에 추가적인 메모리 공간이 필요하며, 각 키와 값의 저장 위치를 찾기 위한 해시 맵 등의 추가 구조를 사용하기 때문에 배열보다 더 많은 메모리를 사용합니다.

따라서 메모리 사용량을 최소화하려면 피보나치 함수의 결과를 저장하는 데에 배열을 활용하는 것이 좋습니다. 예를 들어, 피보나치 수열의 n번째 항을 구하는 함수를 구현한다면, 배열을 사용하여 이미 계산된 결과를 저장하고 필요할 때마다 해당 값을 조회하여 재사용할 수 있습니다.
*/

function fibonacci(n) {
  const memo = [0, 1]; // 초기값으로 0과 1을 저장한 배열

  if (n <= 1) {
    return memo[n]; // n이 0 또는 1인 경우 초기값 반환
  }

  for (let i = 2; i <= n; i++) {
    memo[i] = memo[i - 1] + memo[i - 2]; // 배열에 계산 결과 저장
  }

  return memo[n]; // 결과 반환
}

// 테스트
console.log(fibonacci(0)); // 0
console.log(fibonacci(1)); // 1
console.log(fibonacci(5)); // 5
console.log(fibonacci(10)); // 55
console.log(fibonacci(20)); // 6765

/** 
위의 예시 코드에서는 memo라는 배열을 사용하여 이미 계산된 피보나치 수열의 값들을 저장합니다. n이 0 또는 1인 경우에는 초기값인 memo[0] 또는 memo[1]을 반환하고, 그 외의 경우에는 반복문을 통해 memo 배열에 계산 결과를 저장합니다. 마지막으로 memo[n]을 반환하여 n번째 피보나치 수를 얻습니다.

이렇게 배열을 사용하여 피보나치 수열을 구현하면 중복된 연산을 효율적으로 피할 수 있고, 배열의 메모리 사용량도 딕셔너리보다 적게 됩니다.
*/

// 
/** 
배열의 메모리 차지:
자바스크립트의 숫자(Number) 데이터 타입은 8바이트의 메모리를 사용합니다. 따라서 1부터 1,000,000까지의 숫자로 이루어진 배열을 생성하면 배열의 크기는 약 8 메가바이트입니다.

이를 계산하는 방법은 다음과 같습니다:

숫자 하나당 8바이트의 메모리를 차지하므로, 배열에 들어갈 숫자의 개수를 구합니다. (1,000,000 - 1 + 1 = 1,000,000)
숫자의 개수에 8바이트를 곱하여 전체 메모리 사용량을 구합니다. (1,000,000 * 8 = 8,000,000 바이트)
바이트를 메가바이트로 변환합니다. (8,000,000 바이트 = 8 메가바이트)
따라서, 1부터 1,000,000까지의 숫자로 이루어진 배열은 약 8 메가바이트의 메모리를 차지합니다.
*/