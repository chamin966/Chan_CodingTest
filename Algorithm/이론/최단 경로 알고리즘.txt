일반적으로 자바스크립트로 그래프 관련 문제를 해결할 때는
아래와 같은 2차원 배열인 인접리스트로 표현한다.
index가 노드 번호이고,
배열[index]는 index번 노드의 인접 노드(연결된 노드)번호들이 된다  
[[], [2, 3] [1, 5] [1, 4, 5] [3, 5], [2, 3, 4]]

최단 경로 문제란?
  • 최단 경로 알고리즘은 가장 짧은 경로를 찾는 알고리즘을 의미한다.
  => 간선마다 비용이 다를 경우, 비용이 가장 작은 것을 의미하기도 한다.
  • 다양한 문제 상황
    • 한 지점에서 다른 한 지점까지의 최단 경로
    • 한 지점에서 다른 모든 지점까지의 최단 경로 → 다익스트라 알고리즘
    • 모든 지점에서 다른 모든 지점까지의 최단 경로 → 플로이드 워셜 알고리즘
  • 각 지점은 그래프에서 노드로 표현
  • 지점 간 연결된 도로는 그래프에서 간선으로 표현

최단 경로 알고리즘 동작 과정
  • 최단 거리 테이블은 각 노드에 대한 현재까지의 최단 거리 정보를 가진다.
  • 처리 과정에서 더 짧은 경로를 찾으면 더 짧은 경로로 값을 갱신한다.

최단 경로 알고리즘의 특징
  • 대부분의 최단 경로 알고리즘은 다른 노드를 거쳐갈 때 비용이 감소하는지 확인한다.
  • 깊이 1: ① → ④로 가기 위하여 3원이 필요하다.
  • 깊이 2: ① → ② → ④로 가면 2원이 필요하다. (2번 노드를 거치며 확인 가능)


다익스트라 최단 경로 알고리즘
  • 특정한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로를 계산한다.
  • 다익스트라 최단 경로 알고리즘은 음의 간선이 없을 때 정상적으로 동작한다.
    • 현실 세계의 도로(간선)는 음의 간선으로 표현되지 않는다.
    • 음의 간선이 포함될 때는 벨만 포드(Bellman-Ford) 알고리즘을 사용할 수 있다.
  • 다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류된다.
    • 매 상황에서 가장 비용이 적은 노드를 선택해 임의의 과정을 반복한다.

• 다익스트라 알고리즘의 동작 로직직은 다음과 같다.
  1. 출발 노드를 설정한다.
  2. 최단 거리 테이블을 초기화한다.
  3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
  4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
  → 갱신은 우선순위 큐에 삽입하는 방식으로 자동 갱신되도록 한다.
  5. 위 과정에서 3번과 4번을 반복한다.
  
다익스트라 최단 경로 알고리즘
  • 다익스트라 최단 경로 알고리즘은 “그리디 알고리즘” 유형에 속한다.
  → 매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택해 임의의 과정을 반복한다.
  • 단계를 거치며 한 번 처리된 노드의 최단 거리는 고정되어 더 이상 바뀌지 않는다.
    • 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다.
  • 다익스트라 알고리즘을 수행한 뒤에 테이블에 각 노드까지의 최단 거리 정보가 저장된다.
    -> 최단 거리값이 아니라 A에서 B까지 거치는 최단 경로(노드 순서)를 구하는 것이 목적이라면 
    소스코드에 추가적으로 BFS를 이용하여 경로는 역추적하는 코드를 추가해야 한다.

우선순위 큐(Priority Queue)
  • 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조이다.
  • 예를 들어 여러 개의 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내서
    확인해야 하는 경우에 우선순위 큐를 이용할 수 있다.
  • Python, C++, Java를 포함한 대부분의 프로그래밍 언어에서 표준 라이브러리 형태로 지원한다.

  자료구조: 추출되는 데이터
  스택(Stack): 가장 나중에 삽입된 데이터
  큐(Queue): 가장 먼저 삽입된 데이터
  우선순위 큐(Priority Queue): 가장 우선순위가 높은 데이터

힙(Heap)
  • 우선순위 큐(Priority Queue)를 구현하기 위해 사용하는 자료구조 중 하나다.
  • 최소 힙(Min Heap)과 최대 힙(Max Heap)이 있다.
  • 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 사용된다.
  • 우선 순위 큐 구현 방식에 따른 시간 복잡도
    배열(리스트): 삽입 = O(N)    삭제 = O(N)
    힙(Heap):   삽입 = O(logN) 삭제 = O(logN)

JavaScript의 힙(Heap) 라이브러리
  • JavaScript는 기본적으로 우선순위 큐를 라이브러리로 제공하지 않는다.
  • 최단 경로 알고리즘 등에서 힙(heap)이 필요한 경우 별도의 라이브러리를 사용해야 한다.

다익스트라 최단 경로 알고리즘의 특징 요약
  • 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
    → 이를 위해 힙(Heap) 자료구조를 이용한다.
    → 다시 말해, 현재 상황에서 가장 가까운 노드를 저장해 놓기 위해서 힙 자료구조를 이용한다.
    • 현재의 최단 거리가 가장 짧은 노드를 선택해야 하므로 최소 힙을 사용한다.


다익스트라 최단 경로 알고리즘 동작 과정
  : 일반적으로 노드는 문제 상황에서 나라, 도시, 국가와 같이
  특정한 위치 형태로서 제시되는 경우가 많다.
  : 각 노드들을 연결하는 간선들은 서로 다른 가중치를 가질 수 있다.
  : 이러한 그래프는 인접 리스트 방식으로 표현될 수 있다.

  1. 일단 인접리스트에 각 노드(행 번호)에 따른 거리(열)를 infinity로 초기화한다.
  2. 출발 노드를 거리 0으로 하여 우선 순위 큐(최소힙)에 넣고, 방문 처리한다.
    -> 자기 자신 노드까지의 거리(비용)은 0이기 때문이다. 
  3. 이제 출발 노드가 가지고 있는 인접 노드들의 노드 번호와 거리를 큐에 넣는다.
    -> [노드 번호, 비용] 형태로 큐에 삽입.
    -> 최소힙에 의해 가장 작은 비용을 가진 노드가 맨 앞으로 이동된다.
    -> 최소힙을 사용하기 때문에, 넣었다 빼는 것만으로 가장 최소 비용을 얻을 수 있다.
  4. deq를 실행하면 최소힙에 의해 이전 노드에서 최소 비용으로 이동한 노드가 배출되고,
     현재 노드(now)에 인접한 노드들(graph[now])을 순환하며,
     이동할 가치가 있는 노드인지 확인(현재 최단 거리 테이블에 저장된 비용보다 작은 비용을 가진 노드)하고,
     가치가 있는 노드들의 거리와 현재 노드가 지나온 거리의 합(cost = 거리 + next[1])을 구한다.
  5. 그 합이 최단 거리 테이블에 저장된 해당 노드가 가진 비용(distance[next[0]])보다 작다면
     (기존 a -> b로 가는 최소 비용보다 현재 노드를 거쳐서 a -> now -> b로 가는 비용이 더 작다면)
     최단 거리 테이블의 비용을 갱신하고, 큐에 노드와 비용 정보[cost, next[0]]를 삽입한다.
  6. 다시 인접 노드들의 번호와 거리를 큐에 넣는다.
  7. while문으로 큐가 빌 때까지, 4 ~ 6번 과정을 반복한다.

  이러한 로직으로 작동하기 때문에,
  실질적으로 다익스트라 알고리즘은 각각의 간선들을 단 한번씩만 확인하게 되므로,
  시간복잡도 O(ElogV)를 달성할 수 있다.

다익스트라 알고리즘의 시간 복잡도
  • 힙 자료구조를 이용하는 다익스트라 알고리즘의 시간 복잡도는 𝑶(𝑬𝒍𝒐𝒈𝑽)이다.
  • 노드를 하나씩 꺼내 검사하는 반복문(while문)은 노드의 개수 𝑉 이상의 횟수로는 처리되지 않다.
    -> while문 한 번에 노드와 지나는 간선 한 쌍이 처리되기 때문.
    • 결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총 횟수는
      최대 간선의 개수(𝐸)만큼 연산이 수행될 수 있다.
  • 직관적으로 전체 과정은 𝐸개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사하다.
    • 시간 복잡도를 𝑂(𝐸𝑙𝑜𝑔𝐸)로 판단할 수 있다.
    • 중복 간선을 포함하지 않는 경우에 이를 𝑂(𝐸𝑙𝑜𝑔𝑉)로 정리할 수 있다.
    • O(ElogE) → O(ElogV^2) → O(2ElogV) → O(ElogV)

플로이드 워셜 알고리즘

플로이드 워셜 알고리즘 개요
  • 모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산한다.
  • 플로이드 워셜(Floyd-Warshall) 알고리즘은 다익스트라 알고리즘과 마찬가지로 단계별로 거쳐
    가는 노드를 기준으로 알고리즘을 수행한다.
    → 그러나 플로이드 워셜 알고리즘은 다익스트라 알고리즘과는 달리
    매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않는다.
  • 플로이드 워셜은 2차원 테이블에 최단 거리 정보를 저장한다.
  • 플로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속한다.
    → 점화식에 따라서 2차원 테이블에 있는 최단 거리 정보를 반복적으로 갱신한다.

플로이드 워셜 알고리즘 동작 로직
  • 각 단계마다 특정한 노드 𝐾를 거쳐 가는 경우를 확인하여
    𝐴에서 특정한 노드 𝐾를 거쳐 𝐵로 갈 때 더 짧아지는 경우를 확인하여
    최단 거리 테이블을 갱신한다.
  • 점화식은 다음과 같다.
    D[A][B] = MIN(D[A][B], D[A][K] + D[K][B])
    D[A][B]: A번 노드에서 B번 노드로 가는 데 소요되는 최단 거리값
    MIN(D[A][B], D[A][K] + D[K][B]): A -> B 와 A -> K -> B의 값 비교

플로이드 워셜 알고리즘의 동작 과정
  1. 최단거리 저장을 위한 2차원 테이블을 초기화한다.
     D[i][j]: i번 노드에서 출발하여, j노드에 도착할 때의 비용
     이때, 깊이가 2 이상으로 닿을 수 있는 노드들은 INF로 초기화한다.
  2. 최단거리 테이블을 순회하면서
     점화식 D[A][B] = MIN(D[A][B], D[A][K] + D[K][B])을
     사용하여 테이블을 갱신한다.
  3. 1부터 N(모든 노드 개수)까지 반복하여
     K 노드를 거쳐갈 때와 거쳐가지 않을 때의 비용을 비교하여
    최단 거리 테이블을 완성한다.
  => A노드에서 K노드로 도착하는 D[A][K]와
     K에서 출발하여 B노드로 가는 D[K][B]를 더하면
     A에서 K를 거쳐 B에 도달하는 최소 비용을 알 수 있다.
     이미 1, 2, ...K로 K가 증가하면서,
     D[A][K]에는 이미 A에서 K로 가는 최솟값이 저장되어있고,
     D[K][B]에는 이미 K에서 B로 가는 최솟값이 저장되어있기 때문이다.
     따라서 K를 거쳐가는 것과
     다른 노드를 거쳐 가거나, 직접 연결되는 D[A][B]를
     비교하여 최단 거리 테이블을 갱신하면
     A에서 출발하여 B에 도착하는 모든 경우의 수 중에서 최단 거리를 알 수 있다.
     
     위와 같은 과정을 1 ~ N까지 반복함으로써,
     모든 노드에서 모든 노드로 향하는 최단 거리 테이블을 도출할 수 있게 된다.
     모든 행렬 요소 개수인 K^2에 대한 비교를 각 K번 시행하므로 시간복잡도는 O(N^3)이 된다.
     => 노드의 개수가 𝑁개일 때 알고리즘상으로 𝑁번의 단계를 수행하고
     단계마다 O(N^2)의 연산을 통해 현재 노드를 거쳐 가는 모든 경로를 고려한다.

벨만 포드 최단 경로 알고리즘
  • 음수 간선에 관하여 최단 경로 문제는 다음과 같이 분류할 수 있다.
      1) 모든 간선이 양수인 경우
         다익스트라: 하나의 노드에서 모든 노드에 대한 최소 비용
         플로이드 워셜: 모든 노드에서 모든 노드에 대한 최소 비
      2) 음수 간선이 있는 경우
         1) 음수 순환은 없는 경우
         2) 음수 순환이 있는 경우
  • 벨만 포드 최단 경로 알고리즘은 음의 간선이 포함된 상황에서도 사용할 수 있다.
    • 또한 음수 순환을 감지할 수 있다.
    • 벨만 포드의 기본 시간 복잡도는 𝑂(𝑉𝐸)로 다익스트라 알고리즘에 비해 느리다.
      → 기본적으로 동작 과정에서 다익스트라 알고리즘의 “최적의 해”를 항상 포함한다
        => 다익스트라로 구할 수 있으면 벨만 포드로도 구할 수 있긴 하다.

벨만 포드 알고리즘의 동작 과정
  1. 출발 노드를 설정한다.
  2. 최단 거리 테이블을 초기화한다.
  3. 다음의 과정을 𝑁 − 1번 반복한다.
    1. 전체 간선 𝐸개를 하나씩 확인한다.
    2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
  • 만약 음수 순환이 발생하는지 체크하고 싶다면 세 번째 과정을 한 번 더 수행한다.
    • 이때 최단 거리 테이블이 갱신된다면 음수 순환이 존재하는 것이다

벨만 포드 알고리즘 VS 다익스트라 알고리즘
  • 다익스트라 알고리즘
    • 매번 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
    • 음수 간선이 없다면 최적의 해를 찾을 수 있다.
  • 벨만 포드 알고리즘
    • 매번 모든 간선을 전부 확인한다.
      • 따라서 다익스트라 알고리즘에서의 최적의 해를 항상 포함한다.
    • 다익스트라 알고리즘에 비해서 시간이 오래 걸리지만 음수 순환을 탐지할 수 있다.
