백트래킹
: 일반적으로 그래프/트리의 모든 원소를 '완전 탐색'하기 위한 목적으로 사용할 수 있다.
DFS와의 차이점
1. DFS는 일반적으로 완전 탐색 목적으로, 재귀 함수를 이용해 구현한다.
2. 백트래킹도 재귀 함수를 이용해 구현하는 것이 일반적이지만,
단순히 완전 탐색하는 것이 아니라, 조건에 따라서 '유망한 노드'로 이동한다.
=> 백트래킹은 조건에 상충되지 않은 경우에만 재귀함수를 호출하여 최대한 경우의 수를 줄이는 것이 목적.

주로 2차원 배열을 탐색(arr[x1][y1] : arr[x2][y2])
1) 같은 행에 있는지 체크: x1 === x2
2) 같은 열에 있는지 체크: y1 === y2
3) 대각선에 있는지 체크: abs(x1, x2) === abs(y1, y2);

DFS: 깊이 우선 탐색
Stack(FILO): 선입후출의 자료구조 사용
그래프를 나타내기 위해 주로 인접리스트 표현 방식을 사용한다.

DFS는 그래프 혹은 트리에서 모든 노드를 한 번씩 탐색하기 위한 방법이다.
=> 완전 탐색을 수행하기 위함.

DFS 동작 방식
1. 시작 노드를 스택에 넣고 방문 처리 한다.
2. 스택에 마지막으로 들어 온 노드에 방문하지 않은 인접 노드가 있는지 확인한다.
=> 있다면, 방문하지 않은 인접 노드블 스택에 삽입하고 방문 처리 한다.
=> 없다면, 현재 노드(스택에 마지막으로 들어온 노드)를 스택에서 추출한다.
3. 2번 과정을 더 이상 반복할 수 없을 때까지 반복한다.

DFS를 실제로 구현할 때는 스택 혹은 재귀 함수를 이용한다.

깊이 우선 탐색 사용 예시
1. 더 짧은 코드로 간결히 구현해야 하는 경우
2. 큐 라이브러리를 사용할 수 없는 경우(BFS를 사용할 수 없는 경우)
3. 트리의 순회, 점화식 구현 등 DFS(재귀 구조)에 특화된 문제인 경 우
4. 트리에서 최단 거리 탐색을 구하는 경우
-> 트리에서 두 노드를 잇는 경로가 하나만 존재한다. 

DFS는 도달 가능한 끝 위치까지 도달했다면,
다시 최근의 갈림길로 돌아가서 다른 위치로도
가보는 방식과 유사하다.

*****
DFS 문제는 주로 순열 or 조합 or 트리 or 그래프 or 행렬 탐색 기술을 활용한다.
문제를 만나면 트리나 그래프 탐색의 경우, 인접리스트를 활용하고,
행열 탐색의 경우, dx, dy를 활용하여 상하좌우를 이동할 수 있도록 하고,
분기하여 최대, 최솟값을 구하는 문제의 경우, 순열과 조합을 활용할 수 있는
풀이 방식을 먼저 생각해보는 것이 좋다.

BFS: 너비 우선 탐색
- 그래프 문제 해결의 경우, DFS와 마찬가지로 인접 리스트를 활용한다.
인접 리스트 예시
[
[], // 접근과 연산의 편의를 위해 0번 인덱스에 빈 배열 삽입
[2, 3], // 1번 노드와 2, 3번 노드가 연결되어 있다는 뜻
[1, 4, 5],
[3, 5],
[2, 3 ,4],
]


BFS(너비 우선 탐색)이란?
: 그래프 혹은 트리에서 모든 노드를 한 번씩 탐색하기 위한 기본적인 방법
: 가까운 노드부터 탐색하게 된다. 트리의 경우 같은 레벨의 노드들 먼저 탐색한다.
: 완전 탐색을 수행하기 위해 사용할 수 있는 방법 중 하나
: (모든 간선의 길이가 동일할 때) 주로 최단 거리를 탐색하기 위한 목적으로 쓰임
: 재귀 함수를 사용하지 않고 while문과 큐 자료구조의 조합을 사용한다.
=> DFS는 스택을, BFS는 큐를 사용한다.

BFS 기본 동작 방식
1. 시작 노드를 큐에 넣고 방문 처리한다.
2. 큐에서 원소를 꺼내어 방문하지 않은 인접 노드가 있는지 확인한다.
=> 있다면, 방문하지 않은 인접 노드를 큐에 삽입하고 방문 처리한다.
2. 2번 과정을 더 이상 반복할 수 없을 때(queue.length === 0)까지 반복한다.

BFS 사용 예시
1. 간선의 비용이 '동일'한 상황에서 최단 거리 문제를 해결하는 경우
2. 각각의 연산을 이용하여 목표값으로 가기 위한 최소 연산 횟수를 구하는 경우
=> 그리디 문제 중에서 BFS로 풀 수 있는 경우도 있는데,
분기점이 주어지고 최소 또는 최대 횟수를 구하는 경우 BFS로 간단하게 풀 수 있다. 
3. 완전 탐색을 위해 사용한 DFS 솔루션이 메모리/시간 초과를 받아 BFS로
재 시도하는 경우
-> DFS와 BFS 모두 그래프 탐색 목적으로 사용할 수 있으나,
구현이 익숙하다면 BFS를 추천한다.
코딩테스트에서 DFS로 해결할 수 있는 문제는 BFS로도 해결할 수 있는 경우가 많다.
하지만 DFS는 일반적인 최단 거리 문제를 해결할 수 없다.

BFS와 최단 경로
: BFS는 간선의 비용이 동일할 때, 최단 거리 문제를 해결하기 위해 사용 가능하다.
: BFS는 다익스트라 최단 경로 알고리즘과 유사한 특징이 있다.
-> 다익스트라는 간선의 비용이 서로 다를 수 있을 때 사용 가능하다.
1) 다익스트라 알고리즘은 일반 큐 대신에 우선 순위 큐를 사용한다.
2) 다익스트라는 특정 노드에 대하여 최단 거리값이 갱신될 수 있다.
-> (더 짧은 경로를 찾는 경)