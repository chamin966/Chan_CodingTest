다이나믹 프로그래밍(DP, 동적 계획법)
: 메모리(메모이제이션을 위한 공간)를 더 사용하여 시간 복잡도를 개선할 때 많이 사용된다.
: 구체적으로, 시간 복잡도가 비효율적인 알고리즘이 있을 때
부분 문제의 반복이 발생하는 경우 적용하면 효과적이다.
=> 다이나믹 프로그래밍 문제를 해결하기 위해
점화식(반복되는 부분 문제)을 찾는 것이 핵심적인 과정이다.

다이나믹 프로그래밍의 사용 조건
1. 최적 부분 구조
- 큰 문제를 유사한 형태의 작은 문제로 나눌 수 있으며,
작은 문제의 답을 모아 큰 문제를 해결할 수 있는 형태
=> 재귀 함수(탑다운)나 반복문(바텀업)으로 구현된다.
2. 반복되는 부분 문제
- 동일한 작은 문제를 반복적으로 해결해야 한다.

DP 예시 1) 피보나치 수열
피보나치 수열 예시: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …]
- 점화식: 인접한 항으로 현재 값을 결정하는 관계식을 의미한다.
-> 일반적으로 최적 부분 구조를 만족한다는 특징이 있다.
- 피보나치 수열의 점화식: a𝑛 = a(𝑛−1) + a(𝑛−2) (초기 항: a(1) = 1, a(2) = 1)

• 점화식의 기본적인 구성 요소는 다음과 같다.
1. 초기항
2. 인접한 항과의 관계
• 점화식으로 표현할 수 있다.
• 재귀 함수의 경우 무한 루프에 빠지지 않기 위해 [종료 조건]이 있어야 하는데,
점화식의 초기항이 종료 조건과 같은 역할을 수행한다.

// 피보나치 함수를 재귀함수로 표현
점화식: 𝑎𝑛 = 𝑎𝑛−1 + 𝑎𝑛−2 (초기 항: 𝑎1 = 1, 𝑎2 = 1)
function fibo(x) {
  // 초기항이 종료 조건이 된다
  if(x === 1 || x === 2) return 1;
  // 실질적인 점화식의 내용은 f(x)의 리턴값에 들어간다.  
  return fibo(x - 1) + fibo(x - 2);
}

• 피보나치 수열 문제는 다음의 조건을 만족한다.
1. 최적 부분 구조 → 점화식 형태로 표현 가능
2. 반복되는 부분 문제
• 이미 해결한 문제를 또 해결해야 한다.

• 피보나치 수열의 점화식을 그대로 재귀 함수로 구현하면 어떻게 될까?
→ 중복되는 부분 문제가 발생한다. (이미 구한 값을 불필요하게 반복 계산)
• 다이나믹 프로그래밍의 메모이제이션은 이 문제를 해결할 수 있도록 해준다.

// 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
const memo = new Array(100).fill(0);
// 해당 index에 저장된 값이 0이라면 아직 fibo(index)의 값이 계산되지 않은 것

/**
탑다운
: 큰 문제를 해결하기 위해 작은 문제부터 호출해가면서 답을 점차적으로 완성해가는 방식
: 재귀함수를 활용한다.
*/
function fibo(x) { // 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
  if (x === 1 || x === 2) return 1; // 초기항을 종료조건으로 변환
  // 한 번 해결한 문제는 여러 번 해결하지 않도록 이미 계산해놓았다면 그대로 반환
  if (memo[x] !=== 0) return memo[x];
  // 아직 계산하지 않은 부분이라면 점과식에 따라서 피보나치 결과 반환
  memo[x] = fibo(x - 1) + fibo(x - 2); 
  return memo[x];
}

• 다이나믹 프로그래밍(재귀 함수)의 대표적인 코드 형식은 다음과 같다.
function dp() {
  ① 종료 조건 (초기항)
  ② 이미 해결한 문제라면, 정답을 그대로 반환 (메모이제이션)
  ③ 점화식에 따라 정답 계산 (점화식 내용)
}

• 다이나믹 프로그래밍 문제 해결 접근 순서는 다음과 같다.
1. 문제 이해하기
2. 점화식 찾아내기 → 일반적으로 가장 핵심적인 부분이다.
  => 점화식(인접한 항으로 현재 값을 결정하는 관계식) 구하는 법
  1. 각 위치나 부분까지의 최적의 해를 수열로 나타낼 수 있는지 본다.
  2. 수열로 나타낼 수 있다면, 일정한 규칙을 찾아낸다.
  3. 규칙에따라 점화식과 초기항을 만들어낸다.
3. 구현 방식(상향식/하향식) 결정하기
4. 점화식을 실제 코드로 구현하기

• 다이나믹 프로그래밍 문제는 두 가지 방법으로 접근할 수 있다.
1. 상향식(바텀 업): 반복문을 이용해 초기 항부터 계산한다.
2. 하향식(탑 다운): 재귀 함수로 큰 항을 구하기 위해 작은(이전) 항을 호출하는 방식이다.

=> 이미 구한 함수 값을 담는 테이블을 흔히 DP 테이블이라고 한다.

탑 다운 방식의 경우 stack overflow가 발생할 수 있으므로,
둘다 구현 가능하다면 반복문을 활용한 상향식 방법이 추천된다.

탑다운 방식의 DP(재귀함수 활용)
memo = new Array(100).fill(0);
function fibo(x) {
  if (x == 1 || x == 2) return 1;
  if (memo[x] != 0) return memo[x];
  memo[x] = fibo(x - 1) + fibo(x - 2);
  return memo[x];
}

바텀업 방식의 DP(반복문 활용)
function fibo(x) {
  memo = new Array(100).fill(0);
  memo[1] = 1;
  memo[2] = 1;
  for (let i = 3; i <= x; i++) {
    memo[i] = memo[i - 1] + memo[i - 2];
  }
  return memo[x];
}

DP 예시 2) 창고 털기 문제
• 𝑁개의 창고가 있을 때, 얻을 수 있는 식량의 최댓값을 계산해 보자.
• 이때, 최소한 한 칸 이상 떨어진 창고들만 선택하여 털 수 있다.
  창고1: 1
  창고2: 3
  창고3: 1
  창고4: 5
• 현재 예시에서는 두 번째 창고와 네 번째 창고를 선택했을 때 최댓값인 8을 얻을 수 있다.

• 각 위치까지의 최적의 해를 일종의 수열에서의 각 항으로 볼 수 있다.
• 왼쪽부터 하나씩 창고를 본다고 가정하자.
→ 차례대로 𝑎1, 𝑎2, 𝑎3, …, 𝑎𝑁으로 이해하자.
• 혹은 함수 𝑓(∙) 형태로 표현하기도 하며 그 의미는 다음과 같다.
• f(1): 1번 창고까지 처리했을 때, 최대 식량 값(optimal solution)
• ...
• f(n): 𝑁개의 창고까지 모두 처리했을 때, 최대 식량 값(optimal solution)

f(1) f(2) f(3) f(4) f(5)

f(5) = Math.max(f(4), f(3) + arr(5))
• f(3) = 위치 3까지의 해
• f(4) = 위치 4까지의 해
• arr(5) = 5번 창고에 든 
• 4번째(f(4))를 털었다면, 5번째는 털 수 없다.
• 3번째(f(3))까지만 고려했다면, 5번째는 털 수 있다.

• 창고 털기 문제도 결국 아래와 같은 두 조건을 만족한다.
1. 최적 부분 구조(optimal substructure)
• 큰 문제는 동일한 구조의 작은 문제의 조합으로 해결 가능하다.
• 점화식 그 자체로 이해할 수 있다.
2. 부분 문제의 중복(overlapping sub-problem)
• 해결했던 부분 문제를 또 해결해야 하는 경우가 발생한다.
• 이미 해결한 문제를 [메모이제이션(= 캐)]하여 해결 할 수 있다

- 창고 털기 문제 코드
let n = 4 // 창고 개수
const array = [1, 3, 1, 5]; / 모든 식량 정보

function steal(n, array){
  memo = new Array(100).fill(0);
  memo[0] = array[0];
  memo[1] = Math.max(array[0], array[1]);
  for (let i = 2; i < n; i++) {
    memo[i] = Math.max(memo[i - 1], memo[i - 2] + array[i]);
  }
  return memo[n - 1]
}

DP 예시 3) 창고 털기 문제
• 정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지다.
  1. X가 5로 나누어 떨어지면, 5로 나눈다.
  2. X가 3으로 나누어 떨어지면, 3으로 나눈다.
  3. X가 2로 나누어 떨어지면, 2로 나눈다.
  4. X에서 1을 뺀다.
• 정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 값을 1로 만들고자 한다.
• 연산을 사용하는 횟수의 최솟값을 출력하여라.
• 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.
  • 26 → 25 → 5 → 1

• 다이나믹 프로그래밍 문제를 해결할 때는 점화식을 세우는 것이 가장 중요하다.
• 이걸 위해서는 각 항을 어떻게 정의할 수 있는지가 중요하다.
• 𝑓 𝑥 = 𝑥번째 항 = 𝑥까지 보았을 때 최적의 해(문제에서 요구하는 바)
[정의] 𝑓 𝑥 : 𝑥를 1로 만들기 위해 필요한 연산의 최소 개수
• 𝑓 𝑥 을 구하기 위해서 인접한 항들을 이용할 수 있는가?

• 다이나믹 프로그래밍 문제를 해결할 때는,
직접 손으로 일일이 값을 적어나가며 경험적으로 시도해보는 것도 좋은 방법이다.
→ 일단 시도하다 보면 점화식이 보이는 경우가 종종 있다.
• 𝑓 1 = 0 (이유: 이미 값이 1이다.)
• 𝑓 2 = 1 (이유: 1을 빼거나 2로 나눌 수 있다.)
• 𝑓 3 = 1 (이유: 3으로 나눌 수 있다.)
• 𝑓 4 = 2 (이유: 1을 뺀 뒤에 𝑓 3 혹은 2로 나누고 𝑓 2 )
• 𝑓 5 = 1 (이유: 5로 나눌 수 있다.)
• 𝑓 6 = 2 (이유: 1을 뺀 뒤에 𝑓 5 혹은 2로 나누고 𝑓 3 혹은 3으로 나누고 𝑓 2 )
• …

• 결과적으로 점화식을 세울 수 있다.
• 현재의 예시에서 +1 항은 하나의 연산을 사용하는 행위로 이해할 수 있다.
𝑓 𝑖 = Math.min(𝑓(𝑖 − 1), 𝑓(𝑖/2), 𝑓(𝑖/3), 𝑓(𝑖/5)) + 1


x = 26;
function dp(x){
  memo = new Array(30001).fill(0);
  for(let i = 2; i <= x; i++) {
    // 현재의 수에서 1을 빼는 경우
    memo[i] = memo[i - 1] + 1;
    // 현재의 수가 2로 나누어 떨어지는 경우
    if (i % 2 == 0)
      memo[i] = Math.min(memo[i], memo[parseInt(i / 2)] + 1);
    // 현재의 수가 3으로 나누어 떨어지는 경우
    if (i % 3 == 0)
      memo[i] = Math.min(memo[i], memo[parseInt(i / 3)] + 1);
    // 현재의 수가 5로 나누어 떨어지는 경우
    if (i % 5 == 0)
      memo[i] = Math.min(memo[i], memo[parseInt(i / 5)] + 1);
  }
  return memo[x];
}
