/** 
다이나믹 프로그래밍의 사용 조건
1. 최적 부분 구조
- 큰 문제를 유사한 형태의 작은 문제로 나눌 수 있으며,
작은 문제의 답을 모아 큰 문제를 해결할 수 있는 형태
=> 재귀 함수로 구현된다.
2. 반복되는 부분 문제
- 동일한 작은 문제를 반복적으로 해결해야 한다.
*/

/** 
• 다이나믹 프로그래밍 문제 해결 접근 순서는 다음과 같다.
1. 문제 이해하기
2. 점화식 찾아내기 → 일반적으로 가장 핵심적인 부분이다.
  => 점화식(인접한 항으로 현재 값을 결정하는 관계식) 구하는 법
  1. 각 위치나 부분까지의 최적의 해를 수열로 나타내 본다.
  2. 수열 자체에서 규칙을 발견하거나,
     인접항이나 문제의 조건에 따른 규칙을 발견한다.
  3. 규칙에따라 점화식과 초기항을 만들어낸다.
3. 구현 방식(상향식/하향식) 결정하기
  => 스택 오버플로우를 피하기 위해 바텀업 추천
4. 점화식을 실제 코드로 구현하기

• 다이나믹 프로그래밍 문제는 두 가지 방법으로 접근할 수 있다.
1. 상향식(바텀업): 반복문을 이용해 초기 항부터 계산한다.
2. 하향식(탑다운): 재귀 함수로 큰 항을 구하기 위해 작은(이전) 항을 호출하는 방식이다.
→ 이미 구한 함수 값을 담는 테이블을 흔히 DP 테이블이라고 한다.

탑 다운 방식의 경우 stack overflow나 메모리 초과가 발생할 수 있으므로,
둘다 구현 가능하다면 반복문을 활용한 상향식 방법이 추천된다.
*/

// 피보나치 수열: 바텀업 방식의 DP(반복문 활용)
function fibo(x) {
  memo = new Array(100).fill(0);
  memo[1] = 1;
  memo[2] = 1;
  for (let i = 3; i <= x; i++) {
    memo[i] = memo[i - 1] + memo[i - 2];
  }
  return memo[x];
}

// 피보나치 수열: 탑다운 방식의 DP(재귀함수 활용)

memo = new Array(100).fill(0);
// 바텀업은 memo 배열이 함수 안에 있어도 상관없지만,
// 탑다운은 재귀라서 memo가 함수 밖에 있어야 한다.
function fibo(x) {
  if (x == 1 || x == 2) return 1;
  if (memo[x] != 0) return memo[x];
  memo[x] = fibo(x - 1) + fibo(x - 2);
  return memo[x];
}

